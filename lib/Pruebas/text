bool loading = false;
  List<Map<String, dynamic>> datosC1 = [];
  List<String> selectedColumns = [];
  int currentPage = 0;
  static const int itemsPerPage = 10;
  bool allowReorganize = false;

  @override
  void initState() {
    super.initState();
    _obtenerDatos();
  }

  Future<void> _obtenerDatos() async {
    setState(() {
      loading = true;
    });

    const String baseUrl =
        'https://www.nhubex.com/ServGenerales/General/ejecutarStoredGenericoWithFormat/';
    const String countryCode = 've';
    const String storedName = 'rep_venta_detalle_forma_pago';
    const String attributes =
        '%7B%22DATOS%22:%7B%22uactivo%22:%22shernandez%22,%22fini%22:%222024-04-18%22,%22ffin%22:%222024-04-19%22%7D%7D';
    const String format = 'JSON';
    const String isFront = 'true';

    const String url =
        '$baseUrl$countryCode?stored_name=$storedName&attributes=$attributes&format=$format&isFront=$isFront';

    try {
      final response = await Dio().get(url);
      if (response.statusCode == 200) {
        final Map<String, dynamic> responseData = json.decode(response.data);
        final List<dynamic> c1Data = responseData['RESPUESTA']['C1'];

        Set<String> uniqueColumns = Set<String>();
        for (var item in c1Data) {
          if (item.containsKey('desc_fp')) {
            uniqueColumns.add(item['desc_fp']);
          }
        }
        setState(() {
          selectedColumns.addAll(uniqueColumns);
          datosC1 = List<Map<String, dynamic>>.from(c1Data);
          loading = false;
        });
      } else {
        _mostrarError(
            'Error al obtener los datos del JSON. CÃ³digo de estado: ${response.statusCode}');
      }
    } catch (e) {
      print('Error: $e');
      _mostrarError('Error al cargar los datos.');
    }
  }

  void _mostrarError(String mensaje) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(mensaje)),
    );
  }

  List<Map<String, dynamic>> get currentPageData {
    final startIndex = currentPage * itemsPerPage;
    final endIndex = startIndex + itemsPerPage;
    return datosC1.sublist(
        startIndex, endIndex > datosC1.length ? datosC1.length : endIndex);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Tabla de datos'),
      ),
      body: loading
          ? const Center(child: CircularProgressIndicator())
          : selectedColumns.isNotEmpty
              ? SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: SingleChildScrollView(
                    scrollDirection: Axis.vertical,
                    child: Column(
                      children: [
                        Container(
                          height: 300,
                          child: DataTable(
                            columns: _buildColumns(),
                            rows: _buildRows(),
                          ),
                        ),
                      ],
                    ),
                  ),
                )
              : const Center(
                  child: const Text(
                      'Por el momento no cuentas con informacion en las columnas'),
                ),
    );
  }

  List<DataColumn> _buildColumns() {
    final List<DataColumn> columns = [];
    for (var columna in datosC1.first.keys) {
      columns.add(DataColumn(label: Text(columna)));
    }
    return columns;
  }

  List<DataRow> _buildRows() {
    if (currentPageData.isEmpty) return [];

    return currentPageData.map<DataRow>((data) {
      return DataRow(cells: _buildCells(data));
    }).toList();
  }

  List<DataCell> _buildCells(Map<String, dynamic> data) {
    final List<DataCell> cells = [];
    for (var columna in datosC1.first.keys) {
      cells.add(DataCell(Text('${data[columna]}')));
    }
    return cells;
  }
}
